# Research Methods

# I spent [] hours on this challenge.

i_want_pets = ["I", "want", 3, "pets", "but", "only", "have", 2]
my_family_pets_ages = {"Evi" => 6, "Ditto" => 3, "Hoobie" => 3, "George" => 12, "Bogart" => 4, "Poly" => 4, "Annabelle" => 0}

# Person 1's solution
def my_array_finding_method(source, thing_to_find)
  source # This line is here to make sure all tests initially fail. Delete it when you begin coding.
end

def my_hash_finding_method(source, thing_to_find)
  source # This line is here to make sure all tests initially fail. Delete it when you begin coding.
end

# Identify and describe the Ruby method(s) you implemented.
#
#
#

# Person 2
def my_array_modification_method!(source, thing_to_modify)
  source.dup # This line is here to make sure all tests initially fail. Delete it when you begin coding.
end

def my_hash_modification_method!(source, thing_to_modify)
  source.dup # This line is here to make sure all tests initially fail. Delete it when you begin coding.
end

# Identify and describe the Ruby method(s) you implemented.
#
#
#


# Person 3 Timothy Meixell

=begin Pseudocode:
DEFINE method for sorting arrays that takes parameter 'array'
  MAKE a copy of the array
  SORT the copy by comparing its items turned into strings
  RETURN the array
DEFINE method for sorting hash by age (int in value) that takes parameter 'hash'
  MAKE an array copy of the hash
  SORT the array by comparing each pairs int at index 1
  RETURN the array
=end

def my_array_sorting_method(array)
  array.sort_by{ |x| x.to_s }
end

def my_hash_sorting_method(hash)
  hash.to_a.sort_by{ |x| x[1] }
end

=begin Explanation:
The sort method returns a new array (so I don't have to make a copy), after using the results from the combined comparison operator (<=>). The problem is, you can't compare objects of different types. So I used the Enumerator method sort_by, which uses the keys generated by the block to sort the array. The block takes each item "x" and makes it a string (x.to_s) for comparison, if it isn't already.

The methods to_a and sort_by are non destructive, so I never need to make a copy like in my pseudocode. The method to_a turns the hash into an array. The problem this time is, you can't just compare two arrays. So I use a block to map each array "x" to x[1] for comparison, where the age integer is stored.

In both methods, the array generated is the last value accessed, and so they are implicitly returned. My "trick" for the docs is that I searched for the word "sort" on the ruby doc page and read what I could. If anyone wants to be walked through this, hit me on Slack.
=end


# Person 4
def my_array_deletion_method!(source, thing_to_delete)
  source.dup # This line is here to make sure all tests initially fail. Delete it when you begin coding.
end

def my_hash_deletion_method!(source, thing_to_delete)
  source.dup # This line is here to make sure all tests initially fail. Delete it when you begin coding.
end

# Identify and describe the Ruby method(s) you implemented.
#
#
#


# Person 5
def my_array_splitting_method(source)
  source # This line is here to make sure all tests initially fail. Delete it when you begin coding.
end

def my_hash_splitting_method(source, age)
  source # This line is here to make sure all tests initially fail. Delete it when you begin coding.
end

# Identify and describe the Ruby method(s) you implemented.
#
#
#


# Release 1: Identify and describe the Ruby method you implemented. Teach your
# accountability group how to use the methods.
#
#
#


# Release 3: Reflect!
# What did you learn about researching and explaining your research to others?
#
#
#
#
